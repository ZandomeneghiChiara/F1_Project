# -*- coding: utf-8 -*-
"""F1_Project_Prog.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/197oSmx3H_Pkht_jZcigAhJ7q-Q5sOI9x

**Formula 1 World Championship**

Dataset from https://www.kaggle.com/datasets/rohanrao/formula-1-world-championship-1950-2020?select=results.csv

Formula 1, also known as F1 or Formula One, represents the pinnacle of single-seater auto racing, governed by the Fédération Internationale de l'Automobile (FIA) and owned by the Formula One Group. Since its inaugural season in 1950, the FIA Formula One World Championship has been a premier global motorsport competition. The term "formula" refers to the set of stringent rules and regulations to which all participants' cars must adhere. Each Formula One season comprises a series of races called Grands Prix, held on purpose-built circuits and public road courses around the world.

1. Identification Information
- resultId: Unique identifier for the race result entry.
- raceId: Unique identifier for the race.
- driverId: Unique identifier for the driver.
- constructorId: Unique identifier for the constructor/team.
2. Driver and Constructor Information
- number: The race number of the driver for that event.
3. Starting and Finishing Positions
- grid: Starting position of the driver on the grid.
- position: Finishing position of the driver in the race.
- positionText: Textual representation of the finishing position (e.g., "1", "DNF").
- positionOrder: Numerical order of finishing positions.
4. Performance Metrics
- points: The points awarded to the driver for this race.
- laps: Number of laps completed by the driver.
- time: Total time taken to complete the race.
- milliseconds: Total race time in milliseconds.
- fastestLap: Lap number on which the driver set their fastest lap.
- rank: Rank of the fastest lap within the race.
- fastestLapTime: Time of the driver’s fastest lap.
- fastestLapSpeed: Average speed during the driver’s fastest lap.
5. Race Status
- statusId: Unique identifier indicating the race status (e.g., finished, retired, disqualified).

Each of these categories gives a different perspective on the race results:
- *Identification Information*: Helps in uniquely identifying and linking specific results to races, drivers, and constructors.
- *Driver and Constructor Information*: Provides details about who was driving and for which team.
- *Starting and Finishing Positions*: Offers insight into the driver's starting position and their performance in terms of final position.
- *Performance Metrics*: Detailed performance data, including points scored, lap times, and speeds, which are crucial for performance analysis.
- *Race Status*: Indicates the outcome or status of the driver in the race, whether they finished, retired, or were disqualified.
"""

# import libraries
import pandas as pd
import numpy as np
pd.options.mode.chained_assignment = None

"""# 1 - Explore the dataset"""

re_df = pd.read_csv('results.csv')
re_df

ra_df = pd.read_csv('races.csv')
ra_df

ra_df = ra_df[['raceId','year', 'name']]
ra_df = ra_df.rename(columns = {'name': 'PrixName'})
ra_df

merged_df = pd. merge(re_df, ra_df, on='raceId')
merged_df

co_df = pd.read_csv('constructors.csv')
co_df

co_df = co_df[['constructorId','name']]
co_df = co_df.rename(columns = {'name': 'ConstructorName'})
co_df

merged_df = pd. merge(merged_df, co_df, on='constructorId')
merged_df

dr_df = pd.read_csv('drivers.csv')
dr_df

dr_df = dr_df[['driverId','surname']]
dr_df

dr_df = dr_df[['driverId','surname']]
dr_df = dr_df.rename(columns = {'surname': 'DriverSurname'})
dr_df

merged_df = pd. merge(merged_df, dr_df, on='driverId')
merged_df

df = merged_df

df.info()

df.head()

df.tail()

df.describe()

df.shape

"""# 2 - Cleaning up the dataset"""

# List of features to analyze
features = ['resultId', 'raceId', 'driverId', 'constructorId', 'number', 'grid',
    'position', 'positionText', 'positionOrder', 'points', 'laps', 'time',
    'milliseconds', 'fastestLap', 'rank', 'fastestLapTime', 'fastestLapSpeed',
    'statusId']

resultId_counts = df['resultId'].value_counts()
print("\nresultId counts:")
print(resultId_counts)

raceId_counts = df['raceId'].value_counts()
print("\nraceId counts:")
print(raceId_counts)

driverId_counts = df['driverId'].value_counts()
print("\ndriverId counts:")
print(driverId_counts)

constructorId_counts = df['constructorId'].value_counts()
print("\nconstructorId counts:")
print(constructorId_counts)

number_counts = df['number'].value_counts()
print("\nnumber counts:")
print(number_counts)

grid_counts = df['grid'].value_counts()
print("\ngrid counts:")
print(grid_counts)

position_counts = df['position'].value_counts()
print("\nposition counts:")
print(position_counts)

positionText_counts = df['positionText'].value_counts()
print("\npositionText counts:")
print(positionText_counts)

positionOrder_counts = df['positionOrder'].value_counts()
print("\npositionOrder counts:")
print(positionOrder_counts)

points_counts = df['points'].value_counts()
print("\npoints counts:")
print(points_counts)

laps_counts = df['laps'].value_counts()
print("\nlaps counts:")
print(laps_counts)

time_counts = df['time'].value_counts()
print("\ntime counts:")
print(time_counts)

milliseconds_counts = df['milliseconds'].value_counts()
print("\nmilliseconds counts:")
print(milliseconds_counts)

fastestLap_counts = df['fastestLap'].value_counts()
print("\nfastestLap counts:")
print(fastestLap_counts)

rank_counts = df['rank'].value_counts()
print("\nrank counts:")
print(rank_counts)

fastestLapTime_counts = df['fastestLapTime'].value_counts()
print("\nfastestLapTime counts:")
print(fastestLapTime_counts)

fastestLapSpeed_counts = df['fastestLapSpeed'].value_counts()
print("\nfastestLapSpeed counts:")
print(fastestLapSpeed_counts)

statusId_counts = df['statusId'].value_counts()
print("\nstatusId counts:")
print(statusId_counts)

year_counts = df['year'].value_counts()
print("\nyear counts:")
print(year_counts)

PrixName_counts = df['PrixName'].value_counts()
print("\nPrixName counts:")
print(PrixName_counts)

ConstructorName_counts = df['ConstructorName'].value_counts()
print("\nConstructorName counts:")
print(ConstructorName_counts)

DriverSurname_counts = df['DriverSurname'].value_counts()
print("\nDriverSurname counts:")
print(DriverSurname_counts)

"""# 3 - Handle Outliers, Missing Values and Drop Columns"""

# Identify missing values
# Convert '\N' to NaN in specified columns
columns_to_convert = ['resultId', 'raceId', 'driverId', 'constructorId',
                      'number', 'grid', 'position', 'positionText', 'positionOrder',
                      'points', 'laps', 'time', 'milliseconds', 'fastestLap',
                      'rank', 'fastestLapTime', 'fastestLapSpeed', 'statusId']
df[columns_to_convert] = df[columns_to_convert].replace('\\N', np.nan)
missing_values = df.isna().sum()
print("Missing Values:\n", missing_values)

# drop the columns that I'm interested for my analysis

df.drop(['resultId', 'driverId', 'constructorId', 'number', 'position',
         'positionText', 'time', 'milliseconds', 'fastestLap',
          'rank', 'fastestLapTime', 'fastestLapSpeed'],
          axis=1, inplace = True)
print(df.columns)
print(df.shape)
print(df.describe())

# Manage the Outliers

# Drop columns with any missing values
df_clean = df.dropna(axis=1)

# Function to remove outliers using IQR method

# Remove outliers
df_clean = df[['raceId','grid', 'positionOrder', 'points', 'laps', 'statusId',
               'year','PrixName', 'DriverSurname','ConstructorName']]

# Verify the remaining data
print("Data after removing outliers:")
print(df_clean.shape)

df_clean.head()

df_clean.tail()

df_clean

df_clean.isnull().sum()

"""# 4 - Plots

"""

# Filter data for the years 2020 to 2023
df_filtered = df[(df['year'] >= 2020) & (df['year'] <= 2022)]
df_filtered

raceId_f_counts = df_filtered['raceId'].value_counts()
print("\nraceId_f counts:")
print(raceId_f_counts.shape)  # 61

grid_f_counts = df_filtered['grid'].value_counts()
print("\ngrid_f counts:")
print(grid_f_counts.shape)      # 21

positionOrder_f_counts = df_filtered['positionOrder'].value_counts()
print("\npositionOrder_f counts:")
print(positionOrder_f_counts.shape)   # 20

PrixName_f_counts = df_filtered['PrixName'].value_counts()
print("\nPrixName_f counts:")
print(PrixName_f_counts.shape)   # 32

ConstructorName_f_counts = df_filtered['ConstructorName'].value_counts()
print("\nConstructorName_f counts:")
print(ConstructorName_f_counts)   # 12

DriverSurname_f_counts = df_filtered['DriverSurname'].value_counts()
print("\nDriverSurname_f counts:")
print(DriverSurname_f_counts.shape)   # 30

"""I want analyse this data for the Year 2022"""

import matplotlib.pyplot as plt
import seaborn as sb
import seaborn as sns
import plotly.express as px
import os
import warnings
warnings.filterwarnings("ignore")

"""## 4.1 - Podium Finishes by Constructor"""

# 1. Race Wins for each Constructors
# List of unique constructors in the dataset
constructors = df_filtered['ConstructorName'].unique()

# Loop through each constructor and create a count plot
for constructor in constructors:
    plt.figure(figsize=(5, 4))
    sns.countplot(data=df_filtered[df_filtered['ConstructorName'] == constructor],
                  x='positionOrder', palette='viridis')
    plt.title(f'Race Wins by {constructor}')
    plt.xlabel('Position')
    plt.ylabel('Count')
    plt.xticks(rotation=45)
    plt.tight_layout()
    plt.show()

# 2. Race Wins by Constructors

plt.figure(figsize=(10, 6))
sns.countplot(data=df_filtered, x='ConstructorName', hue='positionOrder',
              order=df_filtered['ConstructorName'].value_counts().index[:12])
plt.title('Race Wins by Constructors')
plt.xlabel('Constructor')
plt.ylabel('Count')
plt.legend(title='Position')
plt.xticks(rotation=45)
plt.show()

"""## 4.2 - Podium Finishes by Drivers"""

# 3. Race Wins for each Driver
# List of unique driver in the dataset
drivers = df_filtered['DriverSurname'].unique()

# Loop through each driver and create a count plot
for driver in drivers:
    plt.figure(figsize=(5, 4))
    sns.countplot(data=df_filtered[df_filtered['DriverSurname'] == driver],
                  x='positionOrder', palette='viridis')
    plt.title(f'Race Wins by {driver}')
    plt.xlabel('Position')
    plt.ylabel('Count')
    plt.xticks(rotation=45)
    plt.tight_layout()
    plt.show()

# 4. Podium Finishes by Drivers

top_drivers = df_filtered['DriverSurname'].value_counts().index[:30]
plt.figure(figsize=(15, 6))
sns.countplot(data=df_filtered[df_filtered['DriverSurname'].isin(top_drivers)], x='DriverSurname', hue='positionOrder')
plt.title('Podium Finishes by Top Drivers')
plt.xlabel('Driver')
plt.ylabel('Count')
plt.legend(title='Position')
plt.xticks(rotation=60)
plt.show()

"""## 4.3 - Points Scored by Each Constructor Over Time"""

# 5. Points Scored by Each Constructor Over Time

# Get the unique contructr name from df_filtered
constructors = df_filtered['ConstructorName'].unique()

# Create a directory to save the plots
os.makedirs('constructor_points_plots', exist_ok=True)

# Iterate over each constructor to create and save a line plot
for constructor in constructors:
    constructors_df = df_filtered[df_filtered['ConstructorName'] == constructor]
    plt.figure(figsize=(10, 5))
    sns.lineplot(data=constructors_df, x='raceId', y='points', marker='o')
    plt.title(f'Points Scored by {constructor} Over Time')
    plt.xlabel('Race ID')
    plt.ylabel('Points')
    plt.grid(True)
    plt.xticks(rotation=45)
    plt.tight_layout()
    plt.show()

"""## 4.4 - Points Scored by Each Driver Over Time"""

# 6. Points Scored by Each Driver Over Time

# Get the unique driver surnames
drivers = df_filtered['DriverSurname'].unique()

# Create a directory to save the plots
os.makedirs('driver_points_plots', exist_ok=True)

# Iterate over each driver to create and save a line plot
for driver in drivers:
    driver_df = df_filtered[df_filtered['DriverSurname'] == driver]
    plt.figure(figsize=(10, 5))
    sns.lineplot(data=driver_df, x='raceId', y='points', marker='o')
    plt.title(f'Points Scored by {driver} Over Time')
    plt.xlabel('Race ID')
    plt.ylabel('Points')
    plt.grid(True)
    plt.xticks(rotation=45)
    plt.tight_layout()
    plt.show()

"""## 4.5 - Points Distribution by Prix Name"""

# 7. Points Distribution by Prix Name

# Set the size of the figure
plt.figure(figsize=(12, 8))

# Create the box plot using Seaborn
sns.boxplot(data=df, x='PrixName', y='points')

# Set the title and labels
plt.title('Points Distribution by Grand Prix', fontsize=16)
plt.xlabel('Grand Prix Name', fontsize=14)
plt.ylabel('Points', fontsize=14)

# Rotate x-axis labels for better visibility
plt.xticks(rotation=90)

# Display the plot
plt.tight_layout()
plt.show()

"""## 4.6 - Average Points by Constructor and Year"""

# 8. Average Points by Constructor and Year

# Set the size of the figure
plt.figure(figsize=(10, 5))

# Create the bar plot using Seaborn
sns.barplot(data=df_filtered, x='year', y='points', hue='ConstructorName', estimator='mean')

# Set the title and labels
plt.title('Average Points by Constructor and Year', fontsize=16)
plt.xlabel('Year', fontsize=14)
plt.ylabel('Average Points', fontsize=14)

# Add a legend with title and adjust its location outside the plot
plt.legend(title='Constructor', bbox_to_anchor=(1.05, 1), loc='upper left')

# Rotate x-axis labels for better visibility
plt.xticks(rotation=45)

# Display the plot
plt.tight_layout()
plt.show()

"""## 4.7 - Average Points by Driver and Year"""

# 9. Average Points by Driver and Year

# Set the size of the figure
plt.figure(figsize=(12, 7))

# Create the bar plot using Seaborn
sns.barplot(data=df_filtered, x='year', y='points', hue='DriverSurname', estimator='mean')

# Set the title and labels
plt.title('Average Points by Driver and Year', fontsize=16)
plt.xlabel('Year', fontsize=14)
plt.ylabel('Average Points', fontsize=14)

# Add a legend with title and adjust its location outside the plot
plt.legend(title='Driver', bbox_to_anchor=(1.05, 1), loc='upper left')

# Rotate x-axis labels for better visibility
plt.xticks(rotation=45)

# Display the plot
plt.tight_layout()
plt.show()

"""## 4.8 - Constructor Performance Comparison by Year"""

# 10. Constructor Performance Comparison by Year

# Identify top 5 drivers based on frequency
top_constructors = df_filtered['ConstructorName'].value_counts().index[:5]

# Filter data for only the top drivers
top_constructors_data = df_filtered[df_filtered['ConstructorName'].isin(top_constructors)]

# Set the size of the figure
plt.figure(figsize=(8, 5))

# Create the line plot using Seaborn
sns.lineplot(data=top_constructors_data, x='year', y='points', hue='ConstructorName')

# Set the title and labels
plt.title('Constructor Performance Comparison by Year', fontsize=16)
plt.xlabel('Year', fontsize=14)
plt.ylabel('Points', fontsize=14)

# Add a legend with title and adjust its location
plt.legend(title='Constructor', loc='upper left')

# Enable grid for better readability
plt.grid(True)

# Display the plot
plt.tight_layout()
plt.show()

"""## 4.9 - Driver Performance Comparison by Year"""

# 11. Driver Performance Comparison by Year

# Identify top 10 drivers based on frequency
top_drivers = df_filtered['DriverSurname'].value_counts().index[:5]

# Filter data for only the top drivers
top_drivers_data = df_filtered[df_filtered['DriverSurname'].isin(top_drivers)]

# Set the size of the figure
plt.figure(figsize=(8, 5))

# Create the line plot using Seaborn
sns.lineplot(data=top_drivers_data, x='year', y='points', hue='DriverSurname')

# Set the title and labels
plt.title('Driver Performance Comparison by Year', fontsize=16)
plt.xlabel('Year', fontsize=14)
plt.ylabel('Points', fontsize=14)

# Add a legend with title and adjust its location
plt.legend(title='Driver', loc='upper left')

# Enable grid for better readability
plt.grid(True)

# Display the plot
plt.tight_layout()
plt.show()

"""# 5 - Machine Learning"""

from sklearn.model_selection import train_test_split
from sklearn.linear_model import LinearRegression, Ridge, Lasso
from sklearn.metrics import mean_squared_error, r2_score

X = df_filtered[['grid']]
y = df_filtered['positionOrder']

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

"""## 5.1 - Linear Regression"""

# Linear Regression

# Initialize the model
linear_reg = LinearRegression()

# Train the model
linear_reg.fit(X_train, y_train)

# Predictions
y_pred_linear = linear_reg.predict(X_test)

# Metrics
mse_linear = mean_squared_error(y_test, y_pred_linear)
r2_linear = r2_score(y_test, y_pred_linear)

print('Linear Regression:')
print(f'Mean Squared Error: {mse_linear}')
print(f'R-squared: {r2_linear}')
print()

"""## 5.2 - Ridge Regression"""

# Initialize the model
ridge_reg = Ridge(alpha=1.0)  # You can tune the alpha parameter

# Train the model
ridge_reg.fit(X_train, y_train)

# Predictions
y_pred_ridge = ridge_reg.predict(X_test)

# Metrics
mse_ridge = mean_squared_error(y_test, y_pred_ridge)
r2_ridge = r2_score(y_test, y_pred_ridge)

print('Ridge Regression:')
print(f'Mean Squared Error: {mse_ridge}')
print(f'R-squared: {r2_ridge}')
print()

"""## 5.3 - Lasso Regression"""

# Initialize the model
lasso_reg = Lasso(alpha=0.1)  # You can tune the alpha parameter

# Train the model
lasso_reg.fit(X_train, y_train)

# Predictions
y_pred_lasso = lasso_reg.predict(X_test)

# Metrics
mse_lasso = mean_squared_error(y_test, y_pred_lasso)
r2_lasso = r2_score(y_test, y_pred_lasso)

print('Lasso Regression:')
print(f'Mean Squared Error: {mse_lasso}')
print(f'R-squared: {r2_lasso}')
print()

"""## 5.4 - Dummy Model"""

# Dummy model predictions (mean)
y_pred_mean = np.full_like(y_test, np.mean(y_train))

# Metrics
mse_dummy = mean_squared_error(y_test, y_pred_mean)
r2_dummy = r2_score(y_test, y_pred_mean)

print('Dummy Model (Mean Prediction):')
print(f'Mean Squared Error: {mse_dummy}')
print(f'R-squared: {r2_dummy}')
print()

"""## 5.5 - Comparison and Visualization"""

# Prepare data for tabular representation
models = ['Linear Regression', 'Ridge Regression', 'Lasso Regression', 'Dummy (Mean)']
mse_scores = [mse_linear, mse_ridge, mse_lasso, mse_dummy]
r2_scores = [r2_linear, r2_ridge, r2_lasso, r2_dummy]

# Create a DataFrame for comparison
comparison_df = pd.DataFrame({
    'Model': models,
    'Mean Squared Error (MSE)': mse_scores,
    'R-squared (R²)': r2_scores
})
comparison_df

# Define colors for each model
colors = ['blue', 'green', 'orange', 'red']

# Plotting MSE and R-squared in a single figure
plt.figure(figsize=(12, 6))

# Plotting Mean Squared Error (MSE)
plt.subplot(1, 2, 1)
sns.barplot(x=models, y=mse_scores, palette=colors)
plt.title('Mean Squared Error (MSE)')
plt.ylim(min(mse_scores) * 0.9, max(mse_scores) * 1.1)
plt.xticks(rotation=45, ha='right')
plt.ylabel('MSE')
plt.grid(True)

# Plotting R-squared (R²)
plt.subplot(1, 2, 2)
sns.barplot(x=models, y=r2_scores, palette=colors)
plt.title('R-squared (R²)')
plt.ylim(min(r2_scores) * 1.1, max(r2_scores) * 1.1)
plt.xticks(rotation=45, ha='right')
plt.ylabel('R²')
plt.grid(True)


plt.tight_layout()
plt.show()